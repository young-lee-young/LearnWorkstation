### 为什么需要goroutine

节省内存，每个线程需要分配一段栈内存，以及内核里的一些资源
节省分配线程的开销（创建和销毁线程要各做一次syscall）
节省大量线程切换带来的开销


### goroutine调度模型

G-P-M模型

G: 存储goroutine运行堆栈、状态及任务函数。每个G需要绑定到P上被调用执行

P: 处理器，可以看作运行在线程上的本地调度器

M: 真正执行逻辑的线程，由操作系统调度器调度和管理


调度器维护一个全局队列
每个P维护一个本地队列，队列为环形队列
G创建后，放入P的本地队列，如果满了，放入到全局队列
G在M中执行结束后，P把G从队列中取出，如果P队列为空，随机从其他P中拿取一部分G

有一定几率从全局队列中获取G


### goroutine调度发展过程

单线程调度（无法使用多核） -> 多线程调度（任务分配不均，可能有进程饿死情况） -> 任务窃取调度（任务再分配实现任务平衡） -> 抢占式调度（协作抢占调度、信号抢占调度）


### goroutine创建过程

* 调度器启动：proc.schedinit，调度器完成相应数量的处理器启动

* 创建goroutine：go关键字经过编译器转换为newproc，参数为参数大小和方法名，获取goroutine结构体，加入处理器运行队列

* 
