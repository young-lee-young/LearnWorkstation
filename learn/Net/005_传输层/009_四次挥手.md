# 四次挥手


### 过程

1. 初始：服务端 ESTABLISHED，客户端 ESTABLISHED
2. 客户端：发送 FIN = 1、seq = u，客户端 -> FIN-WAIT1
3. 服务端：发送 ACK = 1、seq = v、ack = u + 1，服务端 -> CLOSE-WAIT，客户端 -> FIN-WAIT2
4. 服务端：发送 FIN = 1、ACK = 1、seq = w、ack = u + 1，服务端 -> LAST-ACK
5. 客户端：发送 ACK = 1、set = u + 1、ack = w + 1，客户端 -> TIME-WAIT，服务端 -> CLOSED
6. 客户端：等待 2MSL，客户端 -> CLOSED


### 注意⚠️

* TCP 规定 **FIN = 1 的报文段不能携带数据**，但要消耗掉一个序列号


* 服务端第二次挥手的 seq = w，是因为在第一次确认后，可能又发送了一些报文段


* 等待 2MSL（Maximum Segment Life，最长报文段寿命，RFC793 建议为2分钟）

服务端发送 FIN 报文后，需要等客户端的 ACK 报文；客户端发送 ACK 报文后，需要确认服务端是否收到了 ACK 报文，
如果服务端没有收到 ACK 报文，服务端会重发 FIN 报文；所以客户端等待的 2SML：**去向 ACK 最大存活时间 + 服务端可能重试的 FIN 最大存活时间**


* 为什么不能 3 次挥手（为什么第 2 个和第 3 个挥手报文不能合并为 1 个）

客户端发送 FIN 报文时，说明客户端已经没有要发送的数据了，此时服务端要发送 ACK 报文；
但是此时服务端还有要发送的数据，等到服务端数据都发送完毕后，才能发送 FIN 报文


### 问题

1. 服务端大量出现 CLOSE-WAIT 状态

服务端在忙于读和写，没有及时关闭连接，即没有发送 FIN 报文
