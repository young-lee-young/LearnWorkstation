# 三次握手


### 为什么建立连接

1. 使 TCP 双方能够确知对方的存在
2. 使 TCP 双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）
3. 使 TCP 双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配


### 过程

1. 初始：服务端 LISTEN，客户端 CLOSED
2. 客户端：发送 SYN = 1（连接请求）、seq = x，客户端 -> SYN-SEND
3. 服务端：发送 SYN = 1、ACK = 1（连接应答）、seq = y、ack = x + 1，服务端 -> SYN-RCVD
4. 客户端：发送 ACK = 1（再次确认）、seq = x + 1、ack = y + 1，客户端 -> ESTABLISHED
5. 服务端：服务端 -> ESTABLISHED


### 注意⚠️

* TCP 规定 SYN = 1 的报文段不能携带数据，但要消耗掉一个序列号


* 客户端第二次确认时，已经可以携带数据；如果不携带数据，不消耗序列号


* 为什么不能是2次握手

是要确认双方都具有发送和接收数据报文的能力

1. 客户端发送 SYN 报文，客户端知道自己的发送能力没问题
2. 服务端接受到 SYN 报文，发送 SYN、ACK 报文，服务端知道自己的发送、接受能力没有问题，同时知道客户端发送能力没问题
3. 客户端接受到 SYN、ACK 报文，客户端知道服务端发送、接受能力没问题，同时知道自己的接受能力没问题
4. 客户端发送 ACK 报文，服务端接收到 ACK 报文，服务端知道客户端接受能力没问题


### 问题

* 服务器端未收到客户端最后一次的 ACK

服务端不断重试，直至超时，Linux 默认等待63秒（1 + 2 + 4 + 8 + 16 + 32）断开连接

1. 导致 SYN 洪水攻击：

增加积压队列
回收最早的半开 TCP 连接
SYN Cookie


* 建立连接后，客户端出现故障

保活机制：服务端向客户端发送保活探测报文，如果未收到响应则继续发送；尝试次数达到保活探测数仍未收到响应，断开连接
