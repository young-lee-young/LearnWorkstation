# MySQL中函数使用


### 字符函数

* CONCAT()

字符连接

```sql
SELECT CONCAT(firstname, lastname) FROM USER;
```

* CONCAT_WS()

指定分隔符进行字符连接

```sql
SELECT ('.', firstname, lastname) FROM USER;
```

* FORMAT()

数字格式化，返回结果是字符型

```sql
SELECT FORMAT(score, 2) FROM USER; 
```

* LOWER()

转换为小写

```sql
SELECT LOWER(firstname) FROM USER;
```

* UPPER()

转换为大写

```sql
SELECT UPPER(firstname) FROM USER;
```

* LEFT()

获取左侧字符

```sql
SELECT LEFT(firstname, 2) FROM USER;
```

* RIGHT()

```sql
SELECT RIGHT(firstname, 3) FROM USER;
```

* LENGTH()

获取长度

* LTRIM()

去除左侧空格

* RTRIM()

去除右侧空格

* TRIM()

```sql
# 去除前面问号
SELECT TRIM(LEADING '?' FROM firstname) FROM USER;

# 去除后面问号
SELECT TRIM(TRAILING '?' FROM firstname) FROM USER;

# 前后所有问号（不包括中间）
SELECT TRIM(BOTH '?' FROM firstname) FROM USER;
```

* REPLACE()

替换字符串

```sql
# 用!替换?
SELECT REPLACE(firstname, '?', '!') FROM USER;
```

* SUBSTRING()

获取字串

```sql
# 从第3位开始取，取一位，如果只有一个数字，取到字符串结尾，定位符可以是负数
SELECT SUBSTRING(firstname, 3, 1) FROM USER;
```


### 数值函数

* CEIL()

进一取整

* DIV()

整数除法

* FLOOR()

舍一取整

* MOD()

取余

* POWER()

幂运算

* ROUND()

四舍五入

* TRUNCATE()

截断


### 聚合函数

* 取平均值

```sql
SELECT AVG(`列名`) FROM 表名;
```

* COUNT（条数）

工作原理：首先存储引擎查询出结果集，server 层逐个结果判断是否为 NULL，不为 NULL 则加 1

```sql
# 表中的所有数据条数，不管列中是否是NULL
SELECT COUNT(*) FROM 表名;

# 具体列，列不是NULL才会被统计
SELECT COUNT(`列名`) FROM 表名;
```

COUNT(非索引字段)：server 层需要判断 "非索引字段" 是否为 NULL；需要回表查询，理论上最慢

COUNT(索引字段/主键)：server 层仍然需要判断 "索引字段" 是否为 NULL；可以使用覆盖索引

COUNT(1)：只扫描索引树，没有解析数据行的过程；但是 server 层仍然每次需要判断 "1 是否为 NULL"

COUNT(*)： MyISAM：COUNT(\*) 直接返回数据库中记录的数据表行数；InnoDB：由于 InnoDB 支持事务，数据库中不记录数据表行数，MySQL专门优化了 COUNT(\*) 函数直接返回索引树中数据的个数


* MAX（最大值）

```sql
SELECT MAX(`列名`) FROM 表名;
```

* 最小值

```sql
SELECT MIN(`列名`) FROM 表名;
```

* 求和

```sql
SELECT SUM(`列名`) FROM 表名;
```


### 日期函数

* NOW()

* CURDATE()

* CURTIME()

* DATE_ADD()

* DATEDIFF()

* DATE_FORMAT()


### RAND

```mysql
# ORDER BY RAND() 表示随机排序
SELECT `title`, `description` FROM `film` ORDER BY RAND() LIMIT 1;
```

* 原理

1. 创建一个临时表，临时表的字段为 rand、title、description
2. 从原表中取出一行，调用 RAND 方法，将结果和数据放入临时表
3. 针对临时表，将 "rand + 行位置（临时表隐藏主键）" 放入 sort_buffer
4. 对 sort_buffer 排序，取出第一个的 "行位置（临时表隐藏主键）"，回查临时表


* 关于 行位置（主键）

临时表根据数据的大小，有可能是内存表，也可能是磁盘表；如果是内存表，只有行位置而没有主键，如果是磁盘表，只有主键没有行位置

* 慢的原因

1. SQL 执行过程中出现了两次中间结果（临时表 + sort_buffer），都是全长度的（包含所有行）
2. 仅需要一个随机结果，却经历了不必要的排序
3. 调用了多次 RAND 方法


### ORDER BY

* 原理

```mysql
SELECT * FROM `$table_name` WHERE $查询语句 ORDER BY `$column_name`;
```

1. 根据 WHERE 等条件查询
2. 将查询结果放入 sort_buffer
3. 将中间结果集按照 ORDER 字段排序
4. 回表生成完整结果集（如果需要）


* 优化 中间结果集

中间表比较小时，直接放在内存中，中间表大于 sort_buffer_size 时，放在硬盘中

若需要优化内存占用，减小 sort_buffer_size；若需要优化排序查询时间，增大 sort_buffer_size


* 优化 回表生成完整结果集

当行小于 max_length_for_sort_data 时，生成全字段中间表

当行大于 max_length_for_sort_data 时，只生成 '排序字段 + 主键' 中间表，需要回表 


* 最高效 - 索引覆盖

覆盖索引可以跳过生成中间结果集，直接输出查询结果

条件：

1. ORDER 字段需要索引（或在联合索引左侧）
2. 其他相关字段（条件、输出）均在上述索引中
