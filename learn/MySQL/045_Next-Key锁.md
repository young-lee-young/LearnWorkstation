# Next-Key Lock（行锁 + 间隙锁）


### 基础

* 间隙锁

间隙锁功能与行锁相同，只是针对间隙加锁

间隙锁不分读写，不允许在间隙插入；可重复读加锁时，将同时锁住数据及其左右间隙


* 目的

在可重复读的隔离级别下预防部分幻读（加锁的地方无法插入数据）


### 加锁规则

1. 加锁以 Next-Key（一个间隙 + 一个行数据）为最小单位
2. 查找过程中扫描过的范围才加锁
3. **唯一索引（PRIMARY KEY 或 UNIQUE KEY）等值查询**，没有间隙锁，只加行锁
4. 索引等值查询最右一个扫描到的不满足条件值不加行锁
5. 索引覆盖且只加 S锁 时，不锁主键索引


### 数据准备

* 建表

```mysql
CREATE TABLE `next_key_lock` (
    id INT(8) NOT NULL,
    c  INT(8) DEFAULT NULL,
    d  INT(8) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `c` (`c`)
) ENGINE=INNODB CHARSET=utf8 COMMENT '间隙锁测试表';
```


* 数据

```mysql
INSERT INTO next_key_lock VALUES (0, 0, 0), (10, 10, 10), (20, 20, 20), (30, 30, 30), (40, 40, 40), (50, 50, 50);
```


* 主键索引示例

+---------+---+---------+----+----------+----+----------+----+----------+----+----------+----+----------+----+
| (-∞, 0) | 0 | (0, 10) | 10 | (10, 20) | 20 | (20, 30) | 30 | (30, 40) | 40 | (40, 50) | 50 | (50, +∞) | +∞ |
+---------+---+---------+----+----------+----+----------+----+----------+----+----------+----+----------+----+


* c 索引示例

+---------+---+---------+----+----------+----+----------+----+----------+----+----------+----+----------+----+
| (-∞, 0) | 0 | (0, 10) | 10 | (10, 20) | 20 | (20, 30) | 30 | (30, 40) | 40 | (40, 50) | 50 | (50, +∞) | +∞ |
+---------+---+---------+----+----------+----+----------+----+----------+----+----------+----+----------+----+


### Next-Key Lock 实践

* 等值查询间隙锁

事务 A

```mysql
BEGIN;

# 会先锁 (10, 20]（一个间隙 + 一行数据），根据第 4 条，索引等值查询最后一个扫描 20，20 锁解除；最后加锁区间为 (10, 20)
SELECT * FROM next_key_lock WHERE id = 11 FOR UPDATE;
```

事务 B

```mysql
BEGIN;

# 此语句无法执行，因为间隙 (10, 20) 被锁住
INSERT INTO next_key_lock VALUE (12, 12, 12);

# 此语句可以执行，因为 20 没有上锁
SELECT * FROM next_key_lock WHERE id = 20 FOR UPDATE;
```


* 非唯一索引等值锁

事务 A

```mysql
BEGIN;

# 下面语句走覆盖索引，所以只涉及到辅助索引：首先锁 (0, 10]（一个间隙 + 一个行数据），向右扫描时锁上 (10, 20]，根据第 4 条，索引等值查询最后一个扫描 20，20 锁解除；最后加锁区间 (0, 10)、10、(10, 20)
SELECT id FROM next_key_lock WHERE c = 10 LOCK IN SHARE MODE;
```

事务 B

```mysql
BEGIN;

# 此语句无法执行，因为间隙 (10, 20) 被锁住
INSERT INTO next_key_lock VALUE (12, 12, 12);

# 此语句可以执行，因为 20 没有上锁
SELECT * FROM next_key_lock WHERE id = 20 FOR UPDATE;
```


* 唯一索引范围锁

事务 A

```mysql
BEGIN;

# 首先等值查询 20，只锁行锁，向右扫描至 30，锁 (20, 30]，因为是主键索引（唯一索引），所以不用再往右搜索，最后加锁区间 20、(20, 30)、30
SELECT * FROM next_key_lock WHERE id BETWEEN 20 AND 30 FOR UPDATE;
```

事务 B

```mysql
BEGIN;

# 此语句无法执行，因为行 20 被锁住
SELECT * FROM next_key_lock WHERE id = 20 FOR UPDATE;

# 此语句可以执行，因为 12 没有上锁
INSERT INTO next_key_lock VALUE (12, 12, 12);
```


* 非唯一索引范围锁

事务 A
```mysql
BEGIN;

# 先等值查询 20，c 不是唯一索引，锁 (10, 20]，向右扫描至 30，锁 (20, 30]，向右扫描 (30, 40]，根据第 4 条，索引等值查询最后一个扫描 40，40 锁解除
# 最后加锁区间：(10, 20)、20、(20, 30)、30、(30, 40)
SELECT * FROM next_key_lock WHERE c BETWEEN 20 AND 30 FOR UPDATE;
```


* 非索引字段查询

```mysql
BEGIN;

# 因为字段没有索引，走主键索引扫描，锁全表
SELECT * FROM next_key_lock WHERE d = 20 FOR UPDATE;
```
