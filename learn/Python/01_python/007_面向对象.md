# python面向对象编程：Object Oriented Programming（OOP）


### 经典类和新式类

python2：经典类和新式类，经典类不继承object，新式类继承object
python3：都是新式类，继承object
经典类深度优先，新式类广度优先


### __new__ 和 __init__

__new__ 函数是实例创建之前被调用，用来创建实例并返回实例对象，是静态方法
__init__ 函数是实例化之后被调用，用来给实例设置属性等初始值

```python
class TestClass(object):
    def __new__(cls, username, password):
        print('__new__ called')
        print(cls)
        return super(TestClass, cls).__new__(cls)

    def __init__(self, username, password):
        print('__init__ called')
        self.username = username
        self.password = password

    def __str__(self):
        return 'this is test class'
        # 如果没有__str__函数返回的是这个类的地址
        # '<__main__.TestClass object at 0x00000000042816A0>'

    def print_out(self):
        print(self.username, self.password)


test_class = TestClass('lee', '123')
test_class.print_out()
print(test_class)

# __new__ called
# <class '__main__.TestClass'>
# __init__ called
# lee 123
# this is test class
```


### 元类

* 创建类的东西称为元类（type）

```python
def test(self):
    print('动态创建类')

# type(类名, (继承类元组), {"test_func": test})
a = type('类名', (object,), {"test_func": test})

# 实例化类
b = a()
b.test_func()
```

* 创建自己的元类

```python
class LowercaseMeta(type):
    def __new__(cls, name, bases, attrs):
        # 参数name：类名，bases：基类的元组，attrs：属性的字典
        lower_attrs = dict()
        for key, value in attrs.items():
            key = key if key.startswith('__') else key.lower()
            lower_attrs.update({key: value})
        return type.__new__(cls, name, bases, lower_attrs)


class LowercaseClass(metaclass=LowercaseMeta):
    NAME = 'lee'

    def PRINT_NAME(self):
        print(self.NAME)
```


### 类方法和静态方法

实例化可以调用所有的方法和属性
类不可以直接调用实例化方法和实例属性

```python
class TestClass:
    # 类变量
    class_name = __name__

    def __init__(self, name=None):
        # 实例变量
        self.name = name

    def simple_method(self):
        return self.name

    @staticmethod
    def static_method():
        return 1

    @classmethod
    def class_method(cls):
        return cls.class_name
```


### python中函数和方法

python2中都是方法
python3中区分方法和函数，实例化后调用的叫方法，类直接调用的叫函数，方法是自动传参self，函数是主动传参

```python
from types import MethodType, FunctionType


class Test(object):
    def __init__(self):
        pass

    def test_func(self):
        pass


obj = Test()
print(isinstance(obj.test_func, MethodType))
# True
print(isinstance(obj.test_func, FunctionType))
# False
print(isinstance(Test.test_func, MethodType))
# False
print(isinstance(Test.test_func, FunctionType))
# True
```


### hasattr、getattr、setattr

* hasattr，判断对象是否有属性或者方法

```python
class testClass(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @property
    def address(self):
        return 'beijing'

    def get_phone(self):
        return '18400000000'


test_class = testClass('lee', 21)
print(hasattr(test_class, 'name'))
# True
print(hasattr(test_class, 'get_phone'))
# True
```

* getattr，获取对象属性或方法

```python
# 最后一个参数为默认值
print(getattr(test_class, 'address', None))

a = getattr(test_class, 'get_phone', None)
print(a)
# <bound method testClass.get_phone of <__main__.testClass instance at 0x105a75440>>
print(a())
# 18400000000
```


* setattr，设置对象属性，无返回值

```python
setattr(test_class, 'gender', 'male')
```


### __call__ 魔法函数

实现了__call__方法的对象是可调用对象

```python
class A(object):
    def __init__(self):
        pass


class B(object):
    def __init__(self):
        pass

    def __call__(self, *args, **kwargs):
        return 'Hello World'


a = A()
b = B()

print(callable(a))
# False
print(callable(b))
# True
print(b())
# Hello World
```
