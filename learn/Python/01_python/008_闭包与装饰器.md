### 闭包

外层函数嵌套内层函数，内层函数使用外层函数变量，外层函数返回内层函数

```python
def out_func(x):
    def in_func():
        return x
    return in_func


a = out_func(1)
b = a()
```


### 装饰器不带参数，函数带参数

```python
from functools import wraps


def deco_func(func):
    print('out func')
    @wraps(func)
    def in_func(msg):
        print('in func')
        func(msg)
        print('in func end')
    return in_func


@deco_func
def main_func(msg):
    print(msg)


main_func('hello world')
# out func
# in func
# main func
# in func end

# 上面的代码相当于，此时的new_func就是in_func
new_func = deco_func(main_func)
new_func('hello world')
```


### 装饰器带参数

```python
def deco_func_out(prefix):
    print(prefix)
    def deco_func(func):
        print(prefix)
        def deco_in_func(msg):
            print(prefix)
            print('deco in func msg %s' % msg)
            return func(msg)
        return deco_in_func
    return deco_func


@deco_func_out('prefix')
def func(msg):
    print('func msg %s' % msg)


print(func)
func('lee')
```


### 类装饰器不带参数

```python
class Counter(object):
    # 第二步，进入__init__方法，参数是func
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        return self.func(args[0])


# 第一步，走类装饰器
@Counter
def foo(count):
    print(count)


# 第三步，调用函数
foo('hello')
```


### 类装饰器带参数

```python
class Counter(object):
    # 第二步，进入__init__方法，参数是func
    def __init__(self, class_param):
        self.class_param = class_param

    def __call__(self, func):
        def wrapper(param):
            func(self.class_param, param)
        return wrapper


# 第一步，走类装饰器
@Counter('class_name')
def foo(class_param, param):
    print(class_param)
    print(param)


# 第三步，调用函数
foo('hello')
```
