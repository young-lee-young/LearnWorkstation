# 字符串


### 实现

底层实现：通过**简单动态字符串**（Simple Dynamic String，SDS）


* 结构体

```c
// Redis 3.0 之前
struct sdshdr {
    unsigned int len;   // 已使用长度
    unsigned int free;  // 未使用长度
    char buf[];         // 实际保存的字符串
}
```

```c
// Redis 3.0 之后
struct sdshdr {
    unsigned int len;   // 已经使用长度
    unsigned int alloc; // 分配总的长度
    unsigned char flags;// 
    char buf[];         // 实际保存的字符串
}
```


* 其他位数的结构体

```c
// 8 位结构体
struct sdshdr8 {
    uint8_t len;
    uint8_t alloc;
    unsigned char flags;
    char buf[];
}

// 16 位结构体
struct sdshdr16 {
    uint16_t len;
    uint16_t alloc;
    unsigned char flags;
    char buf[];
}

// 32 位结构体
struct sdshdr32 {
    uint32_t len;
    uint32_t alloc;
    unsigned char flags;
    char buf[];
}

// 64 位结构体
struct sdshdr64 {
    uint64_t len;
    uint64_t alloc;
    unsigned char flags;
    char buf[];
}
```


* 扩容、缩容 实现

1. 扩容

SDS 在申请时，会多申请一些内存，称为**内存预分配**；如果容量不够时，小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容

2. 缩容

SDS 在缩容时，不释放多余内存，下次可以直接使用这些内存


### 常用命令

```bash
# 设置键值
SET key value

# 获取值
GET key

# 设置新值，返回旧值
GETSET key value
```


### 问题

* 为什么不采用 C语言 的字符串直接实现

1. O(n) 时间复杂度获取长度
2. 没有较好的扩容机制
3. 特殊字符无法处理


* 使用动态字符串的优点

1. O(1) 时间复杂度获取字符串长度
2. 减少字符串扩容引起的数据搬运次数
3. 可以存储更加复杂的二进制数据
