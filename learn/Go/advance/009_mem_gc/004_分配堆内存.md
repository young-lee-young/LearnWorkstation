### 对象分级

* 对象级别

微对象（Tiny）：(0B - 16B) ，无指针
小对象（Small）：[16B - 32KB]
大对象（Large）：(32KB - )


* 使用

微小对象使用普通 mspan（1 - 67 级 mspan）

大对象使用定制 mspan（0 级 mspan）


### 微小对象分配

微对象分配：从 mcache 拿到 2级 span（16 字节），将多个微对象合并成一个 16 Byte 存入（节约内存）

小对象分配：查表看需要哪个级别的 span，从 mcache 拿到对应级别的 span

* malloc

```go
// runtime/malloc.go/mallocgc
package runtime

const (
	_TinySize     = 16
	_MaxSmallSize = 32768
)

const (
	maxTinySize   = _TinySize
	maxSmallSize  = _MaxSmallSize
)

// 分配内存，返回内存地址
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
    noscan := typ == nil || typ.ptrdata == 0
    // 微对象 & 小对象 内存分配
	if size <= maxSmallSize {
		
		/**
		微对象内存分配
		 */
		if noscan && size < maxTinySize { 
			// Allocate a new maxTinySize block.
			// 级别为 2（tinySpanClass） 的 mspan
			span = c.alloc[tinySpanClass]
			
			// 分配内存，从本地堆缓存 mcache 中找到未使用的 2 级 span
			v := nextFreeFast(span)
			if v == 0 {
				// 如果本地堆缓存满了，和中央索引内存进行交换
				v, span, shouldhelpgc = c.nextFree(tinySpanClass)
			}

        /**
        小对象内存分配
          */
		} else {
			var sizeclass uint8
			// 查 size_to_class 表，查看需要多大的级别的 span
			if size <= smallSizeMax-8 {
				sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]
			} else {
				sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]
			}
			span = c.alloc[spc]
			
			// 分配内存，从本地堆缓存 mcache 中找到未使用的对应级别的 span
			v := nextFreeFast(span)
			if v == 0 {
				// 如果本地堆缓存满了，和中央索引内存进行交换
				v, span, shouldhelpgc = c.nextFree(spc)
			}
		}
	}
}

// nextFreeFast returns the next free object if one is quickly available.
// Otherwise it returns 0.
func nextFreeFast(s *mspan) gclinkptr {
	
}
```


* mcache

mcache替换：mcache 中，每个级别的 mspan 只有 1 个，当 mspan 满了，会从 mcentral 中换一个新的

```go
// runtime/mcache.go/nextFree
package runtime

type mcache struct{
	
}

func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) {
	// refill：重新续订
    c.refill(spc)	
}

// refill acquires a new span of span class spc for c. This span will
// have at least one free object. The current span in c must be full.
func (c *mcache) refill(spc spanClass) {
    s := c.alloc[spc]
	if s != &emptymspan {
		// 将 span 从本地缓存卸载掉
		mheap_.central[spc].mcentral.uncacheSpan(s)
	}
	
	// 从中央缓存找一个 span，放入本地缓存
	s = mheap_.central[spc].mcentral.cacheSpan()
	
	c.alloc[spc] = s
}
```


* mcentral

mcentral 用来索引同一级别的所有 mspan，如果所有 mspan 都满了，需要扩容

```go
// runtime/mcentral.go/cacheSpan
package runtime

// Allocate a span to use in an mcache
// 从中央缓存分配一个 span 给本地缓存 mcache
func (c *mcentral) cacheSpan() *mspan {
    // 上锁
    lock(&c.lock)

	// We failed to get a span from the mcentral so get one from mheap.
	// 中央 mcentral 没有足够的内存
	s = c.grow()
}

// grow allocates a new empty span from the heap and initializes it for c's size class.
// mcentral 本地没有空闲的 span，需要给 Go 内存堆扩容
func (c *mcentral) grow() *mspan {
	// 在 Go 的堆内存上分配内存
	s := mheap_.alloc(npages, c.spanclass, true)
}
```

```go
// runtime/mheap.go/alloc
package runtime

func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
	systemstack(func() {
		s = h.alloc_m(npage, spanclass, large)
	})
}

func (h *mheap) alloc_m(npage uintptr, spanclass spanClass, large bool) *mspan {
    s := h.allocSpanLocked(npage, &memstats.heap_inuse)
}

// 扩容堆内存
func (h *mheap) allocSpanLocked(npage uintptr, stat *uint64) *mspan {
    if !h.grow(npage) {
        return nil
    }
}

func (h *mheap) grow(npage uintptr) bool {
    v, size := h.sysAlloc(ask)
}
```


### 大对象分配

直接从 heapArena 开辟 0 级的 mspan，0 级的 mspan 为大对象定制

* malloc

```go
// runtime/malloc.go/mallocgc
package runtime

const (
	_MaxSmallSize = 32768
)

const (
	maxSmallSize  = _MaxSmallSize
)

// 分配内存，返回内存地址
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
    // 微 & 小对象内存分配
	if size <= maxSmallSize { 
	
	} else {
		// 分配大对象内存
		span = c.allocLarge(size, needzero, noscan)
	}
}
```


* mcache

```go
// runtime/mcache.go/allocLarge
package runtime

// allocLarge allocates a span for a large object
func (c *mcache) allocLarge(size uintptr, needzero bool, noscan bool) *mspan {
	// 分配级别为 0 的 span
	spc := makeSpanClass(0, noscan)
	
	// 在 Go 的堆内存上分配内存
	s := mheap_.alloc(npages, spc, needzero)
}
```
