### 垃圾回收（Garbage Collection）

* 思路

1. 标记-清除
2. 标记-整理
3. 复制


### 标记-清除

标记有引用的对象，剩下就是没有引用的，需要清除

* Root Set（GC Root）：需要标记，不能被回收

1. 被栈上的指针引用
2. 被全局变量指针引用
3. 被寄存器中的指针引用

* 可达性分析标记法

从 GC Root开始，使用广度优先搜索，将所有被 GC 引用的对象，进行标记

* 串行 GC 步骤

1. Stop The World，暂停所有其他协程（防止其他协程使用未被标记的对象）
2. 通过可达性分析，找到无用的堆内存
3. 释放无用堆内存
4. 恢复所有其他协程


### 并发标记

* 三色标记法

黑色：有用，已经分析扫描（内部指针指向已经分析过）
灰色：有用，还未分析扫描
白色：暂时无用或未分析到

* 删除问题

问题：并发标记时，被释放的对象被黑色对象引用，导致在回收时，被引用的对象被清理

解决：删除屏障（并发标记时，对于指针被释放的对象置灰）

杜绝在 GC 标记中被释放的指针被清理

* 插入问题

问题：并发标记时，黑色对象指向了未被引用的白色对象

解决：插入屏障（并发标记时，对指针新指向的白色对象置灰）

杜绝在 GC 标记中被插入的指针被清理


### Go GC

Go 堆内存使用了分级分配，选择最简单的 "标记-清除" 策略，采用混合屏障
