### 堆内存分配

1. 线性分配
2. 链表分配
3. 分级分配

线性分配和链表分配容易出现内存碎片


### Go 堆

Go 每次申请的虚拟内存单元（heapArena）为 64MB，最多有 2^20 = 4194304 个虚拟内存单元，所有的虚拟内存单元组成了 mheap（Go 堆内存）

* mheap 结构体（runtime/mheap.go/mheap）

```go
package runtime

const _NumSizeClasses = 68

const numSpanClasses = _NumSizeClasses << 1

// 描述 Go 堆内存
type mheap struct {
	lock               mutex
	pages              pageAlloc // page allocation data structure
	sweepgen           uint32    // sweep generation, see comment in mspan; written during STW
	sweepdone          uint32    // all spans are swept
	sweepers           uint32    // number of active sweepone calls
	allspans           []*mspan  // all spans out there
	_                  uint32    // align uint64 fields on 32-bit for atomics
	pagesInUse         uint64    // pages of spans in stats mSpanInUse; updated atomically
	pagesSwept         uint64    // pages swept this cycle; updated atomically
	pagesSweptBasis    uint64    // pagesSwept to use as the origin of the sweep ratio; updated atomically
	sweepHeapLiveBasis uint64    // value of heap_live to use as the origin of sweep ratio; written with lock, read without
	sweepPagesPerByte  float64   // proportional sweep ratio; written with lock, read without
	reclaimIndex       uint64
	reclaimCredit      uintptr
	arenas             [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena
	heapArenaAlloc     linearAlloc
	arenaHints         *arenaHint
	arena              linearAlloc
	allArenas          []arenaIdx
	sweepArenas        []arenaIdx
	markArenas         []arenaIdx
	curArena           struct {
		base, end uintptr
	}
	_       uint32 // ensure 64-bit alignment of central
	
	// 描述 136 个 mcentral
	central [numSpanClasses]struct {
		mcentral mcentral
		pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte
	}
	
	spanalloc             fixalloc          // allocator for span*
	cachealloc            fixalloc          // allocator for mcache*
	specialfinalizeralloc fixalloc          // allocator for specialfinalizer*
	specialprofilealloc   fixalloc          // allocator for specialprofile*
	speciallock           mutex             // lock for special record allocators.
	arenaHintAlloc        fixalloc          // allocator for arenaHints
	unused                *specialfinalizer // never set, just here to force the specialfinalizer type into DWARF
}
```

* heapArena 结构体（runtime/mheap.go/heapArena）

```go
package runtime

// 记录申请到的 64 MB 内存信息
type heapArena struct {
	bitmap       [heapArenaBitmapBytes]byte
	spans        [pagesPerArena]*mspan // span 的数组
	pageInUse    [pagesPerArena / 8]uint8
	pageMarks    [pagesPerArena / 8]uint8
	pageSpecials [pagesPerArena / 8]uint8
	checkmarks   *checkmarksMap
	zeroedBase   uintptr
}
```

* mspan（runtime/mheap.go/mspan）

```go
package runtime

type mSpanList struct {
	first *mspan // first span in list, or nil if none
	last  *mspan // last span in list, or nil if none
}

// mspan 是一组相同的小内存单元，而不是一个小内存单元
type mspan struct {
	next *mspan     // next span in list, or nil if none
	prev *mspan     // previous span in list, or nil if none
	list *mSpanList // For debugging. TODO: Remove.

	startAddr uintptr // address of first byte of span aka s.base()
	npages    uintptr // number of pages in span

	manualFreeList gclinkptr // list of free objects in mSpanManual spans

	freeindex uintptr

	nelems uintptr // number of object in the span.

	allocCache uint64

	allocBits  *gcBits
	gcmarkBits *gcBits

	sweepgen    uint32
	divMul      uint16        // for divide by elemsize - divMagic.mul
	baseMask    uint16        // if non-0, elemsize is a power of 2, & this will get object allocation base
	allocCount  uint16        // number of allocated objects
	spanclass   spanClass     // size class and noscan (uint8)
	state       mSpanStateBox // mSpanInUse etc; accessed atomically (get/set methods)
	needzero    uint8         // needs to be zeroed before allocation
	divShift    uint8         // for divide by elemsize - divMagic.shift
	divShift2   uint8         // for divide by elemsize - divMagic.shift2
	elemsize    uintptr       // computed from sizeclass or from npages
	limit       uintptr       // end of data in span
	speciallock mutex         // guards specials list
	specials    *special      // linked list of special records sorted by offset.
}
```

* sizeclass（runtime/sizeclasses.go）

mspan 大小级别

* mcentral（runtime/mcentral.go/mcentral）

一共有 136 个 mcentral，用来索引 68 个需要 GC 扫描的 mspan，68 个不需要 GC 扫描的 mspan

```go
package runtime

type spanClass uint8

// A spanSet is a set of *mspans
type spanSet struct {
	spineLock mutex
	spine     unsafe.Pointer
	spineLen  uintptr
	spineCap  uintptr
	
	index     headTailIndex
}

// 用来索引同一级别的所有 mspan
type mcentral struct {
	spanclass spanClass  // span 级别，0 - 67
	
	partial   [2]spanSet // list of spans with a free object
	full      [2]spanSet // list of spans with no free objects
}
```

* mcache（runtime/mcache.go/mcache）

```go
package runtime

const _NumSizeClasses = 68

const numSpanClasses = _NumSizeClasses << 1

type mcache struct {
	nextSample uintptr // trigger heap sample after allocating this many bytes
	scanAlloc  uintptr // bytes of scannable heap allocated

	tiny       uintptr
	tinyoffset uintptr
	tinyAllocs uintptr

	alloc      [numSpanClasses]*mspan // spans to allocate from, indexed by spanClass
	stackcache [_NumStackOrders]stackfreelist
	flushGen   uint32
}
```
