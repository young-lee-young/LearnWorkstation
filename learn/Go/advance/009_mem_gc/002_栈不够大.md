### 问题

* 协程栈不够大原因（初始栈大小为 2K - 4K）

1. 局部变量太大
2. 栈帧太多

* 解决

1. 变量太大：逃逸
2. 栈帧太多：栈扩容


### 逃逸分析：变量从栈上逃逸到堆上

* 逃逸原因

1. 栈帧回收后，需要继续使用的变量
2. 太大的变量

* 逃逸情况

1. 指针逃逸

如返回了变量的指针

```go
package main

import "fmt"

func a() *int {
	v := 0
	return &v
}

func main() {
	i := a()
	fmt.Println(i)
}
```

2. 空接口逃逸

如果函数参数为 interface{}，函数的实参很可能会逃逸，因为 interface{} 类型的函数往往会使用反射（反射一般要求被反射对象在堆上）

```go
package main

import "fmt"

func main() {
	i := 0
	fmt.Println(i)
}
```

3. 大变量逃逸

过大的变量会导致栈空间不足（64位机器上，一般超过 64KB 的变量会逃逸）


### 栈扩容

* 分段栈（Go 1.13 前）：新开辟一块内存，指针指过去

优点：没有空间浪费

缺点：栈指针会在不连续的空间跳转

* 连续栈（Go 1.13 后）：当空间不足时，扩大 2 倍，当空间使用率不足 1/4 时，缩小为原来的 1/2

优点：空间一直连续

缺点：伸缩时开销大

实现：runtime/asm_amd64.s/runtime·morestack
