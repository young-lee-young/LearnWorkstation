### 问题

协程顺序执行，如果协程特别大，导致其他协程饥饿


### 本地队列 Goroutine 饥饿

* 解决

本地队列 Goroutine 切换

* 切换时机

1. 主动挂起（runtime/proc.go/gopark()）

业务方法调用 gopark 后，gopark 会直接跳转到 schedule()

流程：schedule() -> execute() -> gogo() -> 业务方法（隐式调用 gopark） -> 保存现场 -> schedule()

```go
package runtime

// Puts the current goroutine into a waiting state and calls unlockf on the system stack
// 切换到 g0 栈，并且调用 schedule()
func gopark() {
	mcall(park_m)
}

func park_m() {
	schedule()
}

// mcall switches from the g to the g0 stack and invokes fn(g)
// mcall 切换 'g 协程栈' 到 'g0 协程栈'，并且调用 fn 方法
func mcall(fn func())
```

2. 系统调用完成时

流程：schedule() -> execute() -> gogo() -> 业务方法 -> entrysyscall() -> 系统调用 -> exitsyscall() -> 保存现场 -> schedule()

```go
package runtime

func exitsyscall() {
	Gosched()
}

func Gosched() {
	mcall(gosched_m)
}

// Gosched continuation on g0.
func gosched_m() {
	goschedImpl()
}

func goschedImpl() {
	schedule()
}

// mcall switches from the g to the g0 stack and invokes fn(g)
// mcall 切换 'g 协程栈' 到 'g0 协程栈'，并且调用 fn 方法
func mcall(fn func())
```


### 全局队列 Goroutine 饥饿

* 解决

每 61 次去全局队列中获取 1 个 Goroutine

```go
package runtime

func schedule() {
	if gp == nil {
		// 每 61 次去全局队列中获取 1 个 goroutine
		if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
			lock(&sched.lock)
			gp = globrunqget(_g_.m.p.ptr(), 1)
			unlock(&sched.lock)
		}
	}
}
```
