### 关闭 channel

* 关闭 channel 步骤

1. 加锁
2. 将所有接收者 sudog 出队，将出队的协程加入到**协程链表**
3. 将所有发送者 sudog 出队，将出队的协程加入到**协程链表**
4. 解锁
5. **协程链表**中所有协程唤醒


```go
// runtime/proc.go/gList
package runtime

// A gList is a list of Gs linked through g.schedlink. A G can only be
// on one gQueue or gList at a time.
type gList struct {
	head guintptr
}
```

```go
// runtime/chan.go/closechan
package runtime

func closechan(c *hchan) {
    // 加锁
    lock(&c.lock)
    
    // 设置关闭标志
    c.closed = 1
    
    var glist gList
    
    // 将所有接收者出队
    // release all readers
    for {
        sg := c.recvq.dequeue()
        if sg == nil {
            break
        }
        
        // 加入到协程链表
        glist.push(gp)
    }
    
    // 将所有发送者出队
    // release all writers (they will panic)
    for {
        sg := c.sendq.dequeue()
        if sg == nil {
            break
        }
    
        // 加入到协程链表
        glist.push(gp)
    }
    
    // 解锁
    unlock(&c.lock)
    
    // 唤醒所有协程
    // Ready all Gs now that we've dropped the channel lock.
	for !glist.empty() {
		gp := glist.pop()
		// 唤醒协程
		goready(gp, 3)
	}
}
```

* 关闭 channel 原则

不要从一个 receiver 侧关闭 channel，也不要在有多个 sender 时，关闭 channel


### 被唤醒的接收者

```go
// runtime/chan.go/chanrecv
package runtime

func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    releaseSudog(mysg)
}
```


### 被唤醒的发送者

```go
// runtime/chan.go/

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
	releaseSudog(mysg)
	if closed {
	    // 被唤醒的发送者会 panic
		panic(plainError("send on closed channel"))
	}
}
```
