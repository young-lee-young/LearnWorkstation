### <- 关键字

<- 关键字是一个语法糖，在编译阶段，把 <- 转化为 runtime.chansend1()

* 源码

```go
// runtime/chan.go/chansend1
package runtime

// entry point for c <- x from compiled code
//go:nosplit
func chansend1(c *hchan, elem unsafe.Pointer) {
	chansend(c, elem, true, getcallerpc())
}

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {

}
```


### 发送的情形

* 直接发送：发送数据前，已经有 goroutine 在休眠等待接收

1. 从接收队列里取出一个等待接收的 goroutine
2. 将数据直接拷贝到接收变量中
3. 唤醒接收协程

```go
// runtime/chan.go/chansend
package runtime

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
	// 等待协程队列出队
	if sg := c.recvq.dequeue(); sg != nil {
		// Found a waiting receiver. We pass the value we want to send
		// directly to the receiver, bypassing the channel buffer (if any).
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
		return true
	}
}

func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    if sg.elem != nil {
        sendDirect(c.elemtype, sg, ep)
        sg.elem = nil
    }
    
    // 唤醒接收协程
    // goready 作用和 gopark 相反，gopark 使协程休眠，goready 使协程苏醒 
    goready(gp, skip+1)
}

func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
	dst := sg.elem
	memmove(dst, src, t.size)
}
```


* 放入缓存：没有 goroutine 在休眠等待，但是有缓存空间

1. 获取可存入的缓存地址
2. 将数据拷贝到缓存地址
3. 维护缓冲区索引

```go
// runtime/chan.go/chansend
package runtime

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
	// 判断缓存区是否满了
    if c.qcount < c.dataqsiz {
        // Space is available in the channel buffer. Enqueue the element to send.
        // 获取可用缓存地址
        qp := chanbuf(c, c.sendx)
        
        // 数据拷贝
        typedmemmove(c.elemtype, qp, ep)
        
        // 维护索引
        c.sendx++
        if c.sendx == c.dataqsiz {
            c.sendx = 0
        }
        c.qcount++
        return true
    }
}

// chanbuf(c, i) is pointer to the i'th slot in the buffer.
func chanbuf(c *hchan, i uint) unsafe.Pointer {
	return add(c.buf, uintptr(i)*uintptr(c.elemsize))
}
```


* 休眠等待：没有 goroutine 在休眠等待，而且没有缓存或者缓存满了

1. 将自己包装成 sudog
2. sudog 放入 sendq 队列
3. 休眠并解锁
4. 被唤醒后，数据已经被取走，维护其他数据

```go
// runtime/chan.go/chansend
package runtime

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    // Block on the channel. Some receiver will complete our operation for us.
    // 获取自己的 goroutine
    gp := getg()
    // 将自己包装成 sudog
    mysg := acquireSudog()

    // 将自己放在发送队列
    c.sendq.enqueue(mysg)

    // 将自己休眠，等待被唤醒
    goparkunlock(&c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)
}
```

```go
// runtime/proc.go/goparkunlock
package runtime

// Puts the current goroutine into a waiting state and unlocks the lock.
// The goroutine can be made runnable again by calling goready(gp).
func goparkunlock(lock *mutex, reason waitReason, traceEv byte, traceskip int) {
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
}
```
