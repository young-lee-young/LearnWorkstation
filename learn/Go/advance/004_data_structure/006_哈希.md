### map

* map结构体

```go
package runtime

type hmap struct {
	count      int            // 键值对的数据数量
	flags      uint8          //
	B          uint8          // 2^B = buckets
	noverflow  uint16         //
	hash0      uint32         // 哈希种子
	buckets    unsafe.Pointer // bucketes 指针指向的是由 bmap 组成的数组, array of 2^B Buckets. may be nil if count==0
	oldbuckets unsafe.Pointer // 扩容时指向原 bucket 数组
	nevacuate  uintptr        // 
	extra      *mapextra      //
}
```

* bucket 结构体

```go
package runtime

const (
	bucketCntBits = 3
	bucketCnt     = 1 << bucketCntBits
)

// A bucket for a Go map.
type bmap struct {
	tophash [bucketCnt]uint8 // bucketCnt：1 << 3 == 8，每个桶里可以放 8 个数据
}
```

编译期间会动态创建一个新的结构

```go
package runtime

type bmap struct {
	topbits  [8]uint8     // 哈希值的高 8 位
	keys     [8]keytype   // 键数组
	values   [8]valuetype // 值数组
	pad      uintptr      // 对齐填充
	overflow uintptr      // 溢出桶
}
```

### 初始化

* make

makemap方法（runtime/map.go/makemap）

* 字面量

数据少于 25 个，转化为简单赋值（先 make 一个 map，再进行赋值）

```go
package main

import "fmt"

func main() {
	m := map[string]int{"1": 1, "2": 2, "3": 3}
	fmt.Println(m)
}
```

数据多于 25 个，转化为循环赋值

```go
package main

import "fmt"

func main() {
	m := make(map[string]string, 26)

	kList := []string{"1", "2", "...", "26"}
	vList := []string{"1", "2", "...", "26"}

	for i := 0; i < len(kList); i++ {
		m[kList[i]] = vList[i]
	}
	
	fmt.Println(m)
}
```


### 插入

对 bmap 中的 tophash 进行遍历，把 tophash 值设置为哈希值的前 8 位


### 访问

key -> 哈希函数 -> 哈希值低 B 位值确定 bucket -> 哈希值高 8 位，去 tophash 里去找（可能去溢出桶里找） -> 比较 key -> 返回值


### 扩容

* 为什么需要扩容

哈希碰撞严重，每个 bucket 的溢出桶过多，多个溢出桶退化为链表，导致严重的性能下降

* 扩容触发时机：插入数据（runtime/map.go/mapassign）

1. 装载系数超过 6.5（平均每个槽 6.5 个 key）
2. 使用了太多溢出桶（溢出桶超过了普通桶）

* 扩容类型

1. 等量扩容：数据不多但是溢出桶太多（曾经溢出桶很多数据，后来被删除，溢出桶数据稀疏，整理数据）
2. 翻倍扩容：数据太多，增加普通桶的数量

* 扩容步骤

step 1（runtime/map.go/hashGrow）

1. 创建一组新桶
2. oldbuckets 指向原有的桶数组
3. buckets 指向新的桶数组
4. flags 标记为扩容状态

step 2

1. 将所有数据从旧桶驱逐到新桶
2. 采用渐进式驱逐
3. 每次操作一个旧桶时，将旧桶数据驱逐到新桶
4. 读取时不进行驱逐，只判断读取新桶还是旧桶

step 3

1. 所有旧桶驱逐完成后
2. oldbuckets 回收
