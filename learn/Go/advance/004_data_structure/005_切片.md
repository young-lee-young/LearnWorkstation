### 切片

* 切片结构体

```go
// runtime/slice.go/slice
package runtime

type slice struct {
	array unsafe.Pointer    // 指针指向底层数组
	len   int               // 长度
	cap   int               // 容量
}
```


* 切片本质

切片本质是对数组的引用


* 示例
          | ----- Len ----- |
Data ---> | Var | Var | Var | Var | ... | Var |
          | -------------- Cap -------------- |


### 切片创建

* 根据数组创建

1. 创建数组
2. newobject 创建一个 slice
3. 赋值

```go
package main

import "fmt"

func main() {
	arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9}

	s := arr[4:8] // 根据数组创建
	
	fmt.Println(s)
}

/** 输出：
[5 6 7 8]
 */
```


* 字面量：编译时插入创建数组的代码

1. 创建数组
2. newobject 创建一个 slice
3. 赋值

```go
package main

import "fmt"

func main() {
	s := []int{1, 2, 3, 4}
	
	fmt.Println(s)
}
```

```bash
# 分析创建过程
go build -gcflags -S main.go
```

[slice 字面量创建](images/slice字面量创建.png)


* make：运行时创建数组（runtime/slice.go/makeslice）

1. makeslice 创建 slice 结构体

```go
package main

import "fmt"

func main() {
	s := make([]int, 10)
	
	fmt.Println(s)
}
```

```bash
# 分析创建过程
go build -gcflags -S main.go
```

[slice make 创建](images/slice%20make%20创建.png)


### 切片访问

下标直接访问

range 遍历元素

len() 查看长度

cap() 查看容量


### 切片追加

* 不扩容时，只调整 Len（编译器负责）


* 扩容时，编译器转为调用 runtime.growslice()


### 扩容机制

* 扩容规则

1.18 之前

1. 期望容量大于当前容量 2 倍，使用期望容量
2. 当前切片长度小于 1024，将容量翻倍
3. 当前切片长度大于 1024，每次增加 25%

1.18

1. 期望容量大于当前容量 2 倍，使用期望容量
2. 当前切片长度小于 256，将容量翻倍
3. 当前切片长度大于 256，容量 newcap = oldcap + (oldcap + 3 * 256) / 4


* 扩容代码

```go
runtime/slice.go/growslice
package runtime

func growslice(et *_type, old slice, cap int) {
    // 计算扩容大小
	newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.cap < 1024 {
			newcap = doublecap
		} else {
			for 0 < newcap && newcap < cap {
			    // 1.18 之前
				newcap += newcap / 4
				
				// 1.18 之后
				// Transition from growing 2x for small slices
                // to growing 1.25x for large slices. This formula
                // gives a smooth-ish transition between the two.
                // 从 2 倍到 1.25 倍，下面方法提供一个平缓的过渡
				newcap = oldcap+(oldcap+3*256)/4
			}
			
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
    
	// 内存对齐
    switch {
        // 向上取整
        capmem = roundupsize(uintptr(newcap) * goarch.PtrSize)
    }
	
	// 内存拷贝
    memmove(p, old.array, lenmem)
}

// Returns size of the memory block that mallocgc will allocate if you ask for the size.
func roundupsize(size uintptr) uintptr {
	if size < _MaxSmallSize {
		if size <= smallSizeMax-8 {
			return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])
		} else {
			return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]])
		}
	}
	if size+_PageSize < size {
		return size
	}
	return alignUp(size, _PageSize)
}
```


* ⚠️注意：切片扩容时，并发不安全，注意切片并发要加锁；slice 并发不会报错，但是数据会丢失
