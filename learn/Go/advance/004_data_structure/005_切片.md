### 切片

* 切片结构体

```go
type slice struct {
	array unsafe.Pointer // 指针指向底层数组
	len   int // 长度
	cap   int // 容量
}
```

* 示例
          | ----- Len ----- |
Data ---> | Var | Var | Var | Var | ... | Var |
          | -------------- Cap -------------- |


### 切片创建

* 根据数组创建

```go
package main

import "fmt"

func main() {
	nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}

	s := nums[4:8]
	fmt.Println(s)
}

/** 输出：
[5 6 7 8]
 */
```

* 字面量：编译时插入创建数组的代码

```go
package main

import "fmt"

func main() {
	s := []int{1, 2, 3, 4}
	fmt.Println(s)
}
```

* make：运行时创建数组（runtime/slice.go/makeslice）

```go
package main

import "fmt"

func main() {
	s := make([]int, 10)
	fmt.Println(s)
}
```


### 追加

* 不扩容时，只调整 Len（编译器负责）

* 扩容时，编译器转为调用 runtime.growslice（runtime/slice.go/growslice）


### 扩容机制

* 扩容规则

1. 期望容量大于当前容量2倍，就会使用期望容量
2. 当前切片长度小于 1024，将容量翻倍
3. 当前切片长度大于 1024，每次增加 25%


* 扩容代码

```go
func growslice(et *_type, old slice, cap int) {
    // 计算扩容大小
	newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.cap < 1024 {
			newcap = doublecap
		} else {
			// Check 0 < newcap to detect overflow
			// and prevent an infinite loop.
			for 0 < newcap && newcap < cap {
				newcap += newcap / 4
			}
			// Set newcap to the requested cap when
			// the newcap calculation overflowed.
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
    
	// 内存对齐
    switch {
        // 向上取整
        capmem = roundupsize(uintptr(newcap) * goarch.PtrSize)
    }
	
	// 内存拷贝
    memmove(p, old.array, lenmem)
}

// Returns size of the memory block that mallocgc will allocate if you ask for the size.
func roundupsize(size uintptr) uintptr {
	if size < _MaxSmallSize {
		if size <= smallSizeMax-8 {
			return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])
		} else {
			return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]])
		}
	}
	if size+_PageSize < size {
		return size
	}
	return alignUp(size, _PageSize)
}
```


* ⚠️注意：切片扩容时，并发不安全，注意切片并发要加锁
