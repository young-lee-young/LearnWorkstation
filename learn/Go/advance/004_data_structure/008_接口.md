### 接口

* 隐式接口特点

1. 只要实现了接口的全部方法，就自动实现了接口
2. 可以在不修改代码的情况下抽象出新接口


* 接口值的底层表示

```go
// runtime/runtime2.go/iface
package runtime

type iface struct {
	tab  *itab          // 记录接口类型信息和实现的方法
	data unsafe.Pointer // 记录数据的地址
}

type itab struct {
	inter *interfacetype    // 接口的类型
	_type *_type            // 接口装载的值类型
	hash  uint32
	_     [4]byte
	fun   [1]uintptr        // 值类型实现的方法，可变长，在编译运行时变长
}
```

```go
// runtime/type.go/interfacetype
package runtime

type interfacetype struct {
	typ     _type
	pkgpath name
	mhdr    []imethod
}
```


### 类型断言

* 定义

类型断言是一个使用在接口值上的操作


* 作用

1. 可以将接口值转换为其他类型值（实现或兼容接口）

```go
package main

import "fmt"

type Car interface {
	Drive()
}

type TrafficTool interface {
	Drive()
}

type Truck struct {
	Model string
}

func (t Truck) Drive() {
	fmt.Println("truck driving")
}

func main() {
    // c 并不是 Truck 类型，不能访问 Truck 的成员，即 c.Model 是错误的
    // c 类型是 interface 类型
	var c Car = Truck{}
	
	t1 := c.(Truck)       // 将 Car interface 类型转为 Truck struct 类型
	
	t2 := c.(TrafficTool) // 将 Car interface 类型转为 TrafficTool interface 类型
	
	fmt.Println(t1, t2)
}
```

2. 可以配合 switch 进行类型判断

```go
package main

import "fmt"

type Car interface {
	Drive()
}

type Truck struct {
	Model string
}

func (t Truck) Drive() {
	fmt.Println("truck driving")
}

func main() {
	var c Car = Truck{}
	switch c.(type) {
	case Truck:
		fmt.Println("truck")
	}
}
```


### 结构体和指针实现接口

![结构体和指针实现接口](images/结构体和指针实现接口.png)

* 结构体实现接口

```go
package main

import "fmt"

type Car interface {
	Drive()
}

type Truck struct {
	Model string
}

/**
    使用结构体实现接口
 */
func (t Truck) Drive() {
	fmt.Println(t.Model)
}

func main() {
	// 下面这两种都可以
	var c1 Car = Truck{}    // 结构体初始化变量
	
	var c2 Car = &Truck{}   // 结构体指针初始化变量
	
	fmt.Println(c1, c2)
}
```

2. 结构体指针实现接口

```go
package main

import "fmt"

type Car interface {
	Drive()
}

type Truck struct {
	Model string
}

/**
    使用指针实现接口
 */
func (t *Truck) Drive() {
	fmt.Println(t.Model)
}

func main() {
	// 这种方法可以实现
	var c2 Car = &Truck{}   // 使用指针初始化变量

	// 这种方法不行
	var c1 Car = Truck{}    // 使用结构体初始化变量
	
	fmt.Println(c1, c2)
}
```


### 空接口

* 空接口结构体

```go
// runtime/runtime2.go/eface
package runtime

type eface struct {
	_type *_type
	data  unsafe.Pointer
}
```

当 _type 和 data 均不存在时，才是 nil 接口


* 作用

空接口值可以承载任何数据，作为任意类型的函数入参

函数调用时，将参数生成一个 eface，再传参

```go
// fmt/print.go/Println
package fmt

func Println(a ...interface{}) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}
```
