### 并发问题

* 验证代码

```go
package main

import "sync"

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	m := make(map[int]int)

	go func() {
		for {
			_ = m[1]
		}
	}()

	go func() {
		for {
			m[2] = 2
		}
	}()

	wg.Wait()
}

// 报错：fatal error: concurrent map read and map write
```


* 并发情形举例

A 协程在桶中读取数据时（读取的老桶数据），B 协程驱逐了这个桶，A 协程会读取到错误的数据或者找不到数据


### 并发问题解决

* 给 map 加锁（mutex）


* 原生并发 map：sync.Map


### sync.Map

* 原理

读写操作和追加操作分离


* sync.Map 结构体

![Map 结构体](images/sync_map.png)

```go
// sync/map.go/Map
package sync

type Map struct {
	mu     Mutex        // 锁 dirty
	read   atomic.Value // readOnly 结构体
	dirty  map[interface{}]*entry
	misses int          // 是否命中
}

type readOnly struct {
	m       map[interface{}]*entry
	amended bool // 追加字段，true if the dirty map contains some key not in m.
}

type entry struct {
	p unsafe.Pointer // 指向 map 实际的值
}
```


### 正常读写

检查 Map 的 read 中是否存在读写的键
发现存在，在 m 的 map 中去寻找键值对 -> entry -> 实际值的指针，进行读写


### 追加（涉及扩容，加锁）

检查 Map 的 read 中是否存在追加的键
发现不存在，给 Map 的 mu 加锁，锁 Map 的 dirty
生成新 entry，挂在 dirty 上，Map 的 read 的 amended 设置为 true（表示 read 当中的数据不完整了，在 dirty 中有追加的值）

![sync map 追加](images/sync_map_追加.png)


### 追加后读写（不涉及到扩容）

* 读写

检查 Map 的 read 中是否存在读写的键，如果存在直接读写
发现不存在，检查 Map read 的 amended 字段，如果为 true，给 Map 的 mu 加锁，去 dirty 里面读写
在 dirty 中读取后，将 Map 的 misses 加 1


* Dirty 提升

当 misses 值足够大（等于 dirty 的长度），将 dirty 提升，替换 read，dirty 变为 nil
将 Map 的 read 的 amended 设置为 false
将 Map 的 misses 设置为 0
后续如果有追加的动作，再重建 dirty（重建 dirty 时，要将 read 中的值赋值一份到 dirty）


### 删除

* 正常删除（还没有追加数据，read = dirty）

检查 Map 的 read 中是否存在删除的键
发现存在，在 m 的 map 中去寻找键值对 -> entry -> 将键对应的 entry 的指针置为 nil
GC 会回收 m 中的键

![sync map 正常删除](images/sync_map_正常删除.png)


* 追加后删除（dirty 还没有提升，数据在 read 中没有）

检查 Map 的 read 中是否存在删除的键
发现不存在，给 Map 的 mu 加锁，在 dirty 中寻找到 entry 后，将键对应的 entry 的指针置为 nil

当 dirty 提升后，将键对应的 entry 指针设置为 expunged（删除），重建 dirty 时，不重建此键（重建 dirty 复制键时，不复制这个键）

![sync map dirty 删除键后，提升 dirty 并重建 dirty](images/sync_map_重建dirty.png)
