### 程序入口

runtime/rt0_linux_amd64.s/_rt0_amd64_linux -> runtime/asm_amd64.s/_rt0_amd64 ->

runtime/asm_amd64.s/runtime·rt0_go -> runtime/proc.go/main -> main.go/main

```nasm
// runtime/rt0_linux_amd64.s/_rt0_amd64_linux

TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB)
```


### 过程

* 读取命令行参数（_rt0_amd64）

复制参数数量 argc 和参数值 argv 到栈上

```nasm
// runtime/asm_amd64.s/_rt0_amd64
TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime·rt0_go(SB)
```


* 初始化 g0 执行栈（runtime·rt0_go）

g0 是每个 Go 程序的第一个协程  

g0 是为了调度协程而产生的协程

```nasm
// runtime/asm_amd64.s/runtime·rt0_go

TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0
    // copy arguments forward on an even stack
	MOVQ	DI, AX		// argc
	MOVQ	SI, BX		// argv
	
	// 初始化 g0 协程栈
	
	// 运行时检查
	CALL	runtime·check(SB)
	
	CALL	runtime·args(SB)
	CALL	runtime·osinit(SB)
	CALL	runtime·schedinit(SB)
	
    // create a new goroutine to start program
	MOVQ	$runtime·mainPC(SB), AX		// entry
	PUSHQ	AX
	CALL	runtime·newproc(SB) // 启动新协程
	POPQ	AX

	// start this M
	CALL	runtime·mstart(SB)

	CALL	runtime·abort(SB)	// mstart should never return
	RET
```


* 运行时检测（runtime.check）

1. 检查各种类型的长度
2. 检查指针操作
3. 检查结构体字段的偏移量
4. 检查 atomic 原子操作
5. 检查 CAS 操作
6. 检查栈大小是否是 2 的幂次

```go
// runtime/runtime1.go/check
package runtime

func check() {
    // 检查一些参数，如果不通过，抛出异常
}
```


* 参数初始化（runtime.args）

对命令行中的参数参数进行处理，参数数量赋值给 argc，参数值赋值给 argv

```go
// runtime/runtime1.go/args
package runtime

func args(c int32, v **byte) {
	argc = c
	argv = v
	sysargs(c, v)
}
```


* 调度器初始化（runtime.schedinit）

1. 全局栈空间内存分配
2. 加载命令行参数到 os.Args
3. 堆内存空间的初始化
4. 加载操作系统环境变量
5. 初始化当前系统线程
6. 垃圾回收器的参数初始化
7. 算法初始化（map、hash）
8. 设置 process 数量

```go
// runtime/proc.go/schedinit
package runtime

func schedinit() {

}
```


* 创建主协程（runtime·mainPC + runtime·newproc + runtime·mstart）

1. 创建一个新的协程，执行 runtime.main（至此有 2 个协程，g0 协程和 runtime.main 协程）
2. 放入调度器等待调度
3. 初始化一个 M，用来调度主协程


* 主协程执行主函数

1. 执行 runtime 包中的 init 方法
2. 启动 GC 垃圾回收器
3. 执行用户包依赖的 init 方法
4. 执行用户主函数 main.main()

```go
// runtime/proc.go/main
package runtime

//go:linkname main_main main.main，在链接阶段，将 main_main() 方法链接到用户程序 main.go/main 上
func main_main()

// The main goroutine.
func main() {
    // runtime init
    doInit(&runtime_inittask) // Must be before defer.
    
    // 启动垃圾回收
    gcenable()
    
    // 用户包 init
    doInit(&main_inittask)

    // 执行用户程序 main 方法
    fn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime
    fn()
}
```
