# 数据库事务



### 命令

```mysql
# 查看是否是自动提交，默认是自动提交
SHOW VARIABLES LIKE "%autocommit%";

# 关闭自动提交
SET AUTOCOMMIT = 0;

# 开始事务
BEGIN;
# 或者
START TRANSACTION;

# 提交
COMMIT;
```



### 四个特性

1. 原子性：要么都成功，要么都失败（通过 UndoLog 实现）
2. 隔离性：允许多个事务同时对数据库进行修改和读写（通过 MVCC 和 锁 实现）
3. 一致性：是最终目标，由其他三个特性保证
4. 持久性：事务结束后，修改永久，不会丢失（通过 RedoLog 和 BinLog 实现）



### 原子性

UndoLog是一条链表，链表头部是最新的旧记录，链表尾部最早的旧记录


* UndoLog

存储引擎层（InnoDB），记录的是数据的历史版本


* 为什么 UndoLog 能保证原子性

如果某条语句执行错误，需要执行回滚操作，通过 UndoLog去回滚



### 持久性

WAL：Write Ahead Log（预写日志：先写日志，再写磁盘）


* RedoLog

存储引擎层（InnoDB），记录操作记录（写 RedoLog，更新内存）


* BinLog

MySQL 层，记录操作记录


* 二阶段提交

获取数据 -> 判断是否在内存中（不在从磁盘中读取数据到内存）-> 返回数据（**引擎层**）

-> 更改数据 -> 写入新数据（**执行器层**）

-> 新数据更新到内存 -> 写入 RedoLog，此时标记为 prepare 状态（**引擎层**）

-> 写 BinLog -> 提交事务，处于 commit 状态（**执行器层**）



### 问题

* 为什么 RedoLog 直接写入磁盘，而数据需要先缓存在内存中，合适的时机刷入磁盘

RedoLog 为顺序读写，数据写入随机读写，因此 RedoLog 写入的很快，数据的写入很慢

* RedoLog 和 BinLog 区别

1. RedoLog 引擎层，BinLog MySQL层
2. RedoLog 是物理日志，记录的是 "在某个数据页上做了什么修改"；BinLog 是逻辑日志，记录的是语句的原始逻辑
3. RedoLog 是循环写，固定的空间会用完，BinLog 是追加写入

* 为什么用二阶段提交

如果使用多个引擎，必须使用 BinLog，如果使用 InnoDB，就要使用 RedoLog；二阶段提交是保证两份日志的一致

prepare -> BinLog -> commit

主要是用 BinLog 恢复数据

如果在 prepare 后崩溃，重启后发现没有 commit，会进行回滚；在 RedoLog 和 BinLog 不存在这个更新数据

如果在 BinLog 后崩溃，重启后发现没有 commit，会进行 commit；在 RedoLog 和 BinLog 中存在这个更新数据
