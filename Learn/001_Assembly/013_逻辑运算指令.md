# 逻辑运算指令



### 与运算：and

有0则0

```assembly
AND 目的操作数, 源操作数
```

源操作数：立即数、通用寄存器、存储器

目的操作数：通用寄存器、存储器

两个操作数不能同时为存储器操作数



### 或运算：or

有1则1

```assembly
OR 目的操作数, 源操作数
```

源操作数：立即数、通用寄存器、存储器

目的操作数：寄存器、存储器

两个操作数不能同时为存储器操作数



### 异或运算：xor(exclusive or)

不相同为1，相同为0

```assembly
XOR 目的操作数, 源操作数

xor ax, ax ; 寄存器清零
```

源操作数：立即数、寄存器、存储器

目的操作数：寄存器、存储器

两个操作数不能同时为存储器操作数



### 非运算：not

按位取反

```assembly
NOT 目的操作数
```

目的操作数：寄存器、存储器，不能为立即数



### 逻辑左移：shl(shift logical left)

将各二进制位左移，最低位补零，最高位送入 CF 寄存器



### 循环左移：rol(rotate left)

将各二进制位左移，最高位放入最低位，同时将最高位送入 CF 寄存器



### 逻辑右移：shr(shift logical right)

将各二进制位右移，最高位补0，最低位送 CF 寄存器



### 循环右移：ror(rotate right)

将各二进制位右移，最低位放入最高位，同时将最低位送入 CF 寄存器



### 算术左移：sal(shift arithmetic left)

同逻辑左移



### 算术右移：sar(shift arithmetic right)

将各二进制位右移，最高位放入最高位，同时将最低位送入 CF 寄存器



### 带进位循环左移：rcl(rotate left through carry)

将各二进制位左移，将 CF 寄存器中的值送入最低位，将最高位送入 CF 寄存器



### 带进位循环右移：rcr(rotate right through carry)

将各二进制位右移，将 CF 寄存器中的值送入最高位，将最低位送入 CF 寄存器