### 流程

schedule() -> execute() -> gogo() -> 业务方法 -> goexit()


### g0 stack

* schedule（runtime/proc.go/schedule()）

```go
package runtime

func schedule() {
	// 选择一个协程 g
	
	execute(g)
}
```

* execute（runtime/proc.go/execute()）

```go
package runtime

func execute(g) {
	gogo(g.sched)
}
```

* gogo（runtime/stubs.go/gogo()，汇编实现，runtime/asm_amd64.s/runtime·gogo）

在 gogo 中插入 goexit 栈帧

切换 PC 到 协程的 sched.pc


### g stack

* 业务方法

* goexit（runtime/stubs.go/goexit()，汇编实现，runtime/asm_amd64.s/runtime·goexit）

执行完业务方法，退回到在 gogo 方法中插入的栈帧 goexit，在汇编中调用 runtime·goexit1（runtime/proc.go/goexit1()）

```go
package runtime

func goexit1() {
	mcall(goexit0)
}

func goexit0(gp *g) {
	schedule()
}

// mcall switches from the g to the g0 stack and invokes fn(g)
// mcall 切换 'g 协程栈' 到 'g0 协程栈'，并且调用 fn 方法
func mcall(fn func(*g))
```
